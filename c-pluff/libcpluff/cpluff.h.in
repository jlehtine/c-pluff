/*-------------------------------------------------------------------------
 * C-Pluff, a plug-in framework for C
 * Copyright 2006 Johannes Lehtinen
 *-----------------------------------------------------------------------*/

/*
 * The public API header file
 */

#ifndef CPLUFF_H_
#define CPLUFF_H_

/* Define CP_API to declare API functions */
#if defined(__WIN32__)
#if defined(CP_BUILD) && defined(DLL_EXPORT)
#define CP_API __declspec(dllexport)
#elif !defined(CP_BUILD) && !defined(CP_STATIC)
#define CP_API __declspec(dllimport)
#else
#define CP_API
#endif
#elif defined(CP_BUILD) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3))
#define CP_API __attribute__ ((visibility ("default")))
#else /* Not restricting link time visibility of non-API symbols */
#define CP_API
#endif

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

/** @name C-Pluff interface */
/*@{*/


/* ------------------------------------------------------------------------
 * Constants
 * ----------------------------------------------------------------------*/

/** @name Constants */
/*@{*/

/**
 * @name Version information
 * Header file version information can be used for compile time checks.
 */
/*@{*/

/** The C-Pluff release version string */
#define CP_RELEASE_VERSION "@PACKAGE_VERSION@"

/** The C-Pluff API version (integer) */
#define CP_API_VERSION @CP_API_CURRENT@

/** The C-Pluff API revision (integer) */
#define CP_API_REVISION @CP_API_REVISION@

/** The C-Pluff API backwards compatibility age (integer) */
#define CP_API_AGE @CP_API_AGE@

/*@}*/


/**
 * @name Error codes
 * Most of the interface functions return error codes. The returned
 * error code either indicates successful completion of the operation
 * or some specific kind of error. Some functions do not return an error
 * code because they never fail.
 */
/*@{*/

/** Operation performed successfully (has zero value) */
#define CP_OK 0

/** An unspecified error occurred */
#define CP_ERR_UNSPECIFIED 1

/** Not enough memory or other operating system resources available */
#define CP_ERR_RESOURCE 2

/** The specified object is unknown to the framework */
#define CP_ERR_UNKNOWN 3

/** An I/O error occurred */
#define CP_ERR_IO 4

/** Malformed plug-in data when loading a plug-in */
#define CP_ERR_MALFORMED 5

/** Plug-in conflicts with an existing plug-in when loading a plug-in */
#define CP_ERR_CONFLICT 6

/** Plug-in dependencies could not be satisfied */
#define CP_ERR_DEPENDENCY 7

/** An error in a plug-in runtime or plug-in framework runtime */
#define CP_ERR_RUNTIME 8

/** An ongoing operation conflicts with the requested operation */
#define CP_ERR_DEADLOCK 9

/*@}*/


/**
 * @name Flags for cp_load_plugins
 * These constants can be orred together for the flags
 * parameter of \Ref{cp_load_plugins}.
 */
/*@{*/

/** 
 * This flag enables upgrades of installed plug-ins by unloading
 * the old version and installing the new version.
 */
#define CP_LP_UPGRADE 0x01

/**
 * This flag causes all plug-ins to be stopped before any
 * plug-ins are to be upgraded.
 */
#define CP_LP_STOP_ALL_ON_UPGRADE 0x02

/**
 * This flag causes all plug-ins to be stopped before any
 * plugins are to be installed (also if new version is to be installed
 * as part of an upgrade).
 */
#define CP_LP_STOP_ALL_ON_INSTALL 0x04

/**
 * Setting this flag causes the currently active plug-ins to be restarted
 * after all changes to the plug-ins have been made (if they were stopped).
 */
#define CP_LP_RESTART_ACTIVE 0x08

/*@}*/
/*@}*/


/* ------------------------------------------------------------------------
 * Data types
 * ----------------------------------------------------------------------*/

/** @name Data types */
/*@{*/


/** @name Opaque types */
/*@{*/

/**
 * An opaque type representing a plug-in context.
 */
typedef struct cp_context_t cp_context_t;

/**
 * An opaque type representing a plug-in instance.
 */
typedef struct cp_plugin_t cp_plugin_t;

/*@}*/


/* Forward type definitions */
typedef struct cp_implementation_info_t cp_implementation_info_t;
typedef struct cp_plugin_import_t cp_plugin_import_t;
typedef struct cp_ext_point_t cp_ext_point_t;
typedef struct cp_cfg_element_t cp_cfg_element_t;
typedef struct cp_extension_t cp_extension_t;
typedef struct cp_plugin_info_t cp_plugin_info_t;
typedef struct cp_plugin_event_t cp_plugin_event_t;


/** @name Library information */
/*@{*/

/**
 * Implementation information structure contains information about
 * the library implementation.
 *
 * @see cp_get_implementation_info
 */
struct cp_implementation_info_t {

	/** The release version */
	char *release_version;
	
	/** The version of the library API */
	int api_version;
	
	/** The revision of the library API */
	int api_revision;
	
	/** The backwards compatibility age of the library API */
	int api_age;
  
	/** The canonical host type */
	char *host_type;
	
	/** The type of multi-threading support, or NULL for none */
	char *multi_threading_type;
	
};

/*@}*/


/** @name Plug-in information */
/*@{*/

/**
 * Plug-in structure captures information about a plug-in.
 *
 * @see cp_get_plugin_info
 * @see cp_get_plugin_infos
 */
struct cp_plugin_info_t {
	
	/** Human-readable, possibly localized plug-in name */
	char *name;
	
	/** Unique identifier */
	char *identifier;
	
	/** Version string */
	char *version;
	
	/** Human-readable, possibly localized provider name */
	char *provider_name;
	
	/** Path of the plugin directory, or NULL if not known */
	char *plugin_path;
	
	/** Number of imports */
	unsigned int num_imports;
	
	/** Imports */
	cp_plugin_import_t *imports;

    /**
     * The plug-in runtime library path, relative to the plug-in directory,
     * or NULL if none
     */
    char *lib_path;
    
    /** The name of the start function, or NULL if none */
    char *start_func_name;
    
    /** The name of the stop function, or NULL if none */
    char *stop_func_name;

	/** Number of extension points provided by this plug-in */
	unsigned int num_ext_points;
	
	/** Extension points provided by this plug-in */
	cp_ext_point_t *ext_points;
	
	/** Number of extensions provided by this plugin */
	unsigned int num_extensions;
	
	/** Extensions provided by this plug-in */
	cp_extension_t *extensions;

};

/**
 * Enumeration of possible version matching criteria.
 *
 * @see cp_plugin_import_t
 */
typedef enum cp_version_match_t {

	/** No version criteria for the dependency */
	CP_MATCH_NONE,
	
	/** Perfect version match is required */
	CP_MATCH_PERFECT,
	
	/**
	 * Equivalent version is required. An equivalent version has the same
	 * major and minor version and the same or more recent revision.
	 */
	CP_MATCH_EQUIVALENT,
	
	/**
	 * Compatible version is required. A compatible version has the same
	 * major version number and the same or more recent minor version.
	 */
	CP_MATCH_COMPATIBLE,
	
	/** Same or more recent version is required */
	CP_MATCH_GREATEROREQUAL
	
} cp_version_match_t;

/**
 * Information about plug-in import.
 *
 * @see cp_plugin_info_t
 */
struct cp_plugin_import_t {
	
	/** Identifier of the imported plug-in */
	char *plugin_id;
	
	/** Version to be matched, or NULL if none */
	char *version;
	
	/** Version matching rule */
	cp_version_match_t match;
	
	/** Whether this import is optional (1 for optional, 0 for mandatory) */
	int optional;
};

/**
 * Extension point structure captures information about an extension
 * point.
 *
 * @see cp_plugin_info_t
 */
struct cp_ext_point_t {
	
	/**
	 * Human-readable, possibly localized extension point name or NULL
	 * if not available
	 */
	char *name;
	
	/**
	 * Local identifier uniquely identifying the extension point within the
	 * providing plug-in
	 */
	char *local_id;
	
	/** Unique identifier of the extension point */
	char *global_id;

	/**
	 * Path to the extension schema definition (relative to the plug-in directory)
	 * or NULL if none.
	 */
	char *schema_path;
};

/**
 * Extension structure captures information about an extension.
 *
 * @see cp_plugin_info_t
 */
struct cp_extension_t {
	
	/** 
	 * Human-readable, possibly localized, extension name or NULL if not
	 * available
	 **/
	char *name;
	
	/**
	 * Local identifier uniquely identifying the extension within the
	 * providing plug-in or NULL if not available
	 */
	char *local_id;

    /** Unique identifier of the extension or NULL if not available */
    char *global_id;
	 
	/** Unique identifier of the extension point */
	char *ext_point_id;
	
	/** Extension configuration (starting with the extension element) */
	cp_cfg_element_t *configuration;
};

/**
 * Configuration element contains configuration information for an extension.
 *
 * @see cp_extension_t
 */
struct cp_cfg_element_t {
	
	/** Name of the configuration element */
	char *name;

	/** Number of attributes */
	unsigned int num_atts;
	
	/**
	 * Attribute name, value pairs (alternating, values possibly localized)
	 */
	char **atts;
	
	/** The value (text contents) of this configuration element, possibly localized */
	char *value;
	
	/** The parent, or NULL if root node */
 	cp_cfg_element_t *parent;
 	
 	/** The index among siblings (0-based) */
 	unsigned int index;
 	
 	/** Number of children */
 	unsigned int num_children;

	/** Children */
	cp_cfg_element_t *children;
};

/*@}*/


/** @name Plug-in state */

/*@{*/

/**
 * An enumeration of possible plug-in states.
 *
 * @see cp_event_listener_t
 * @see cp_get_plugin_state
 */
typedef enum cp_plugin_state_t {

	/**
	 * Plug-in is not installed. No plug-in information has been
	 * loaded.
	 */
	CP_PLUGIN_UNINSTALLED,
	
	/**
	 * Plug-in is installed. At this stage the plug-in information has
	 * been loaded but its dependencies to other plug-ins has not yet
	 * been resolved. The plug-in runtime has not been loaded yet.
	 * The extension points and extensions provided by the plug-in
	 * have been registered.
	 */
	CP_PLUGIN_INSTALLED,
	
	/**
	 * Plug-in dependencies have been resolved. At this stage it has
	 * been verified that the dependencies of the plug-in are satisfied
	 * and the plug-in runtime has been loaded but not started.
	 * Plug-in is resolved when dependent plug-ins are being
	 * resolved or before the plug-in is started. Plug-in is put
	 * back to installed stage if its dependencies are being
	 * uninstalled.
	 */
	CP_PLUGIN_RESOLVED,
	
	/**
	 * Plug-in is starting. The plug-in has been resolved and the start
	 * function (if any) of the plug-in runtime is about to be called.
	 * A plug-in is started when explicitly requested by the client
	 * program or by some other plug-in.
	 */
	CP_PLUGIN_STARTING,
	
	/**
	 * Plug-in is stopping. The stop function (if any) of the plug-in
	 * runtime is about to be called. A plug-in is stopped if the start
	 * function fails or if it is active and stopping is explicitly
	 * requested by the client program or by some other plug-in or if
	 * it is active and its dependencies or the plug-in itself is being
	 * uninstalled.
	 */
	CP_PLUGIN_STOPPING,
	
	/**
	 * Plug-in has been successfully started and it has not yet been
	 * stopped.
	 */
	CP_PLUGIN_ACTIVE
	
} cp_plugin_state_t;

/**
 * Describes a plug-in status event.
 *
 * @see cp_add_event_listener
 */
struct cp_plugin_event_t {
	
	/** The identifier of the affected plug-in */
	char *plugin_id;
	
	/** Old state of the plug-in */
	cp_plugin_state_t old_state;
	
	/** New state of the plug-in */
	cp_plugin_state_t new_state;
	
};

/**
 * An event listener function called synchronously after a plugin state change.
 * An event listener function should return promptly and it must not register
 * or unregister event listeners. Attempts at changing plug-in state within the event
 * listener function may fail to prevent deadlocks.
 * 
 * @param ctx the associated plug-in context
 * @param event te plug-in state change event
 * @see cp_add_event_listener
 */
typedef void (*cp_event_listener_t)(cp_context_t *ctx, const cp_plugin_event_t *event);

/**
 * A start function called to start a plug-in. The start function must return
 * non-zero on success and zero on failure. If the start fails then the
 * stop function (if any) is called to clean up plug-in state. Attempts at changing
 * plug-in state within the start function may fail to prevent deadlocks.
 * 
 * @param ctx the associated plug-in context
 * @return non-zero on success, or zero on failure
 */
typedef int (*cp_start_t)(cp_context_t *ctx);

/**
 * A stop function called to stop a plugin. Attempts at changing
 * plug-in state within the stop function may fail to prevent deadlocks.
 */
typedef void (*cp_stop_t)(void);

/*@}*/


/** @name Error handling */
/*@{*/

/** 
 * An error handler function called when an error occurs. An error
 * handler function should return promptly and it must not register or
 * unregister error handlers. The error message may be localized.
 * Attempts at changing plug-in state within the error
 * handler function may fail to prevent deadlocks.
 * 
 * @param ctx the associated plug-in context (NULL during context creation)
 * @param msg the possibly localized error message
 * @see cp_add_error_handler
 * @see cp_set_fatal_error_handler
 */
typedef void (*cp_error_handler_t)(cp_context_t *ctx, const char *msg);

/*@}*/
/*@}*/


/* ------------------------------------------------------------------------
 * Function declarations
 * ----------------------------------------------------------------------*/

/** @name Functions */
/*@{*/

/** @name Library information */
/*@{*/

/**
 * Returns static information about the library implementation.
 * This function can be called at any time.
 *
 * @return static information about the library implementation
 */
cp_implementation_info_t * CP_API cp_get_implementation_info(void);

/*@}*/


/** @name Library initialization */
/*@{*/

/**
 * Initializes the plug-in framework. This function must be called
 * by the client program before calling any other plug-in framework
 * functions except \Ref{cp_get_implementation_info}. This function may be
 * called several times but it is not thread-safe. Library resources
 * should be released by calling \Ref{cp_destroy} when the framework is
 * not needed anymore.
 *
 * Additionally, to enable localization support, the main program should
 * set the current locale using setlocale(LC_ALL, "") before calling
 * this function.
 */
void CP_API cp_init(void);

/**
 * Destroys the plug-in framework and releases any global resources.
 * The plug-in framework is only destroyed after this function has
 * been called as many times as \Ref{cp_init}. Plug-in framework functions
 * other than \Ref{cp_init} and \Ref{cp_get_implementation_info} must not be called
 * after the plug-in framework has been destroyed.
 */
void CP_API cp_destroy(void);

/**
 * Sets the fatal error handler called on non-recoverable errors. The default error
 * handler prints the error message out to standard error and aborts the program.
 * Fatal error handler is called with NULL context. If the user specified error handler
 * returns, the framework will abort the program. Setting NULL error handler will
 * restore the default handler. This function is typically called as part of the client
 * program initialization and it is not thread-safe.
 * 
 * @param error_handler the fatal error handler
 */
void CP_API cp_set_fatal_error_handler(cp_error_handler_t error_handler);

/*@}*/


/** @name Plug-in context management */
/*@{*/

/**
 * Creates a new plug-in context which is an instance of the C-Pluff plug-in framework.
 * Plug-ins are loaded and installed into a specific context. An application
 * may have more than one plug-in context but the plug-ins that interact with
 * each other should be placed in the same context. The resources associated with
 * the context are released by calling \Ref{cp_destroy_context} when the context is not
 * needed anymore.
 * 
 * @param error_handler an initial error handler, or NULL if none
 * @param error pointer to the location where error code or CP_OK is stored, or NULL
 * @return the newly created plugin context, or NULL on failure
 */
cp_context_t * CP_API cp_create_context(cp_error_handler_t error_handler, int *error);

/**
 * Destroys the specified plug-in context and releases the associated resources.
 * Stops and unloads all plug-ins in the context. The context and the associated
 * data structures such as plug-in information must not be accessed after calling
 * this function.
 * 
 * @param ctx the context to be destroyed
 */
void CP_API cp_destroy_context(cp_context_t *ctx);

/**
 * Registers an error handler function with a plug-in context. The handler is called
 * synchronously when an error occurs. For example, failures to start and register
 * plug-ins are reported to the registered error handlers. There can be several
 * error handlers registered with the same context.
 * 
 * @param ctx the plug-in context
 * @param error_handler the error handler to be added
 * @return CP_OK (0) on success, CP_ERR_RESOURCE if out of resources, or CP_ERR_DEADLOCK
 * 		if called from an error handler
 */
int CP_API cp_add_error_handler(cp_context_t *ctx, cp_error_handler_t error_handler);

/**
 * Removes an error handler from a plug-in context.
 * 
 * @param ctx the plug-in context
 * @param error_handler the error handler to be removed
 * @return CP_OK (0) on success, CP_ERR_UNKNOWN if the error handler is unknown,
 * 		or CP_ERR_DEADLOCK if called from an error handler
 */
int CP_API cp_remove_error_handler(cp_context_t *ctx, cp_error_handler_t error_handler);

/**
 * Registers an event listener with a plug-in context. The event listener is called
 * synchronously immediately after a plug-in state change. There can be several
 * listeners registered with the same context.
 * 
 * @param ctx the plug-in context
 * @param event_listener the event_listener to be added
 * @return CP_OK (0) on success, CP_ERR_RESOURCE if out of resources, or
 * 		CP_ERR_DEADLOCK if called from an event listener
 */
int CP_API cp_add_event_listener(cp_context_t *ctx, cp_event_listener_t event_listener);

/**
 * Removes an event listener from a plug-in context.
 * 
 * @param ctx the plug-in context
 * @param event_listener the event listener to be removed
 * @return CP_OK (0) on success, CP_ERR_UNKNOWN if the event listener is unknown,
 * 		or CP_ERR_DEADLOCK if called from an event listener
 */
int CP_API cp_remove_event_listener(cp_context_t *ctx, cp_event_listener_t event_listener);

/**
 * Registers a directory of plug-ins with a plug-in context. The
 * plug-in context will scan the directory when \Ref{cp_load_plugins} is called.
 * Returns CP_OK if the directory has already been registered.
 * 
 * @param ctx the plug-in context
 * @param dir the directory
 * @return CP_OK (0) on success, or CP_ERR_RESOURCE if insufficient system resources
 */
int CP_API cp_add_plugin_dir(cp_context_t *ctx, const char *dir);

/**
 * Unregisters a previously registered directory of plug-ins from a plug-in context.
 * Does not delete the directory itself. Plug-ins already loaded from the
 * removed directory are not affected. Does nothing
 * if the directory has not been registered.
 * 
 * @param ctx the plug-in context
 * @param dir the previously registered directory
 */
void CP_API cp_remove_plugin_dir(cp_context_t *ctx, const char *dir);

/*@}*/


/** @name Plug-in management */
/*@{*/

/**
 * Loads a plug-in from the specified path and returns static information about
 * the loaded plug-in. The plug-in is installed to the specified plug-in
 * context. If operation fails then NULL is returned. The caller must
 * release the returned information by calling \Ref{cp_release_plugin_info} as soon
 * as it does not need the information anymore.
 * 
 * @param ctx the plug-in context
 * @param path the installation path of the plug-in
 * @param error pointer to the location for the returned error code, or NULL
 * @return pointer to the information structure or NULL if error occurs
 */
cp_plugin_info_t * CP_API cp_load_plugin(cp_context_t *ctx, const char *path, int *error);

/**
 * Scans for plug-ins in the registered plug-in directories, installing
 * new plug-ins and upgrading installed plug-ins. This function can be used to
 * initially load the plug-ins and to later rescan for new plug-ins.
 * 
 * When several versions of the same plug-in is available the most recent
 * version will be installed. The upgrade behavior depends on the specified
 * flags. If \Ref{CP_LP_UPGRADE} is set then upgrades to installed plug-ins are
 * allowed. The old version is unloaded and the new version installed instead.
 * If \Ref{CP_LP_STOP_ALL_ON_UPGRADE} is set then all active plug-ins are stopped
 * if any plug-ins are to be upgraded. If \Ref{CP_LP_STOP_ALL_ON_INSTALL} is set then
 * all active plug-ins are stopped if any plug-ins are to be installed or
 * upgraded. Finally, if \Ref{CP_LP_RESTART_ACTIVE} is set all currently active
 * plug-ins will be restarted after the changes (if they were stopped).
 * 
 * When removing plug-in files from the plug-in directories, the
 * plug-ins to be removed must be first unloaded. Therefore this function
 * does not check for removed plug-ins.
 * 
 * @param ctx the plug-in context
 * @param flags the bitmask of flags
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_load_plugins(cp_context_t *ctx, int flags);

/**
 * Starts a plug-in. The plug-in is first resolved, if necessary, and all
 * imported plug-ins are started. If the plug-in is already starting then
 * this function blocks until the plug-in has started or failed to start.
 * If the plug-in is already active then this function returns immediately.
 * If the plug-in is stopping then this function blocks until the plug-in
 * has stopped and then starts the plug-in.
 * 
 * @param ctx the plug-in context
 * @param id identifier of the plug-in to be started
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_start_plugin(cp_context_t *ctx, const char *id);

/**
 * Stops a plug-in. First stops any importing plug-ins that are currently
 * active. Then stops the specified plug-in. If the plug-in is already
 * stopping then this function blocks until the plug-in has stopped. If the
 * plug-in is already stopped then this function returns immediately. If the
 * plug-in is starting then this function blocks until the plug-in has
 * started (or failed to start) and then stops the plug-in.
 * 
 * @param ctx the plug-in context
 * @param id identifier of the plug-in to be stopped
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_stop_plugin(cp_context_t *ctx, const char *id);

/**
 * Stops all active plug-ins.
 * 
 * @param ctx the plug-in context
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_stop_all_plugins(cp_context_t *ctx);

/**
 * Unloads a plug-in. The plug-in is first stopped if it is active.
 * 
 * @param ctx the plug-in context
 * @param id identifier of the plug-in to be unloaded
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_unload_plugin(cp_context_t *ctx, const char *id);

/**
 * Unloads all plug-ins. This effectively stops all plug-in activity and
 * releases the resources allocated by the plug-ins.
 * 
 * @param ctx the plug-in context
 * @return CP_OK (0) on success, an error code on failure
 */
int CP_API cp_unload_all_plugins(cp_context_t *ctx);

/*@}*/


/** @name Plug-in information */
/*@{*/

/**
 * Returns static information about the specified plug-in. The caller must
 * release the information by calling \Ref{cp_release_plugin_info} when the information
 * is not needed anymore.
 * 
 * @param ctx the plug-in context
 * @param id identifier of the plug-in to be examined
 * @param error filled with an error code, if non-NULL
 * @return pointer to the information structure or NULL if error occurs
 */
cp_plugin_info_t * CP_API cp_get_plugin_info(cp_context_t *ctx, const char *id, int *error);

/**
 * Releases a previously obtained plug-in information structure. The
 * information must not be accessed after it has been released.
 * 
 * @param ctx the plug-in context
 * @param plugin the plug-in information structure to be released
 */
void CP_API cp_release_plugin_info(cp_context_t *ctx, cp_plugin_info_t *plugin);

/**
 * Returns static information about the installed plug-ins. The caller must
 * release the information by calling \Ref{cp_release_plugin_infos} when the
 * information is not needed anymore.
 * 
 * @param ctx the plug-in context
 * @param error filled with an error code, if non-NULL
 * @param num filled with the number of returned plug-ins, if non-NULL
 * @return pointer to a NULL-terminated list of pointers to plug-in information
 * 			or NULL if error occurs
 */
cp_plugin_info_t ** CP_API cp_get_plugin_infos(cp_context_t *ctx, int *error, int *num);

/**
 * Releases a previously obtained plug-in information list. The
 * information must not be accessed after it has been released.
 * 
 * @param ctx the plug-in context
 * @param plugins the plug-in information to be released
 */
void CP_API cp_release_plugin_infos(cp_context_t *ctx, cp_plugin_info_t **plugins);

/**
 * Returns the current state of the specified plug-in. Returns
 * CP_PLUGIN_UNINSTALLED if the specified plug-in identifier is unknown.
 * 
 * @param ctx the plug-in context
 * @param id the plug-in identifier
 * @return the current state of the plug-in
 */
cp_plugin_state_t CP_API cp_get_plugin_state(cp_context_t *ctx, const char *id);

/*@}*/
/*@}*/
/*@}*/

#ifdef __cplusplus
}
#endif /*__cplusplus*/

#endif /*CPLUFF_H_*/
