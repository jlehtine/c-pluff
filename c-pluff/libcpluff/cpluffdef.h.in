/*-------------------------------------------------------------------------
 * C-Pluff, a plug-in framework for C
 * Copyright 2006 Johannes Lehtinen
 *-----------------------------------------------------------------------*/

/** @file
 * Common defines shared by C-Pluff C and C++ APIs.
 * This file is automatically included by the top level C and C++
 * API header files. There should be no need to include it explicitly.
 */

#ifndef CPLUFFDEF_H_
#define CPLUFFDEF_H_


/* ------------------------------------------------------------------------
 * Symbol visibility
 * ----------------------------------------------------------------------*/

/**
 * @defgroup symbolVisibility Symbol visibility
 * @ingroup cDefines cxxDefines
 *
 * Macros for controlling inter-module symbol visibility and linkage. These
 * macros have platform specific values. #CP_EXPORT, #CP_IMPORT and #CP_HIDDEN
 * can be reused by plug-in implementations for better portability. The
 * complexity is mostly due to Windows DLL exports and imports.
 *
 * @anchor symbolVisibilityExample
 * Each module should usually define its own macro to declare API symbols with
 * #CP_EXPORT and #CP_IMPORT as necessary. For example, a mobule could define
 * a macro @c MY_API in the API header file as follows.
 *
 * @code
 * #ifndef MY_API
 * #  define MY_API CP_IMPORT
 * #endif
 * @endcode
 *
 * By default the API symbols would then be marked for import which is correct
 * when client modules are including the API header file. When compiling the
 * module itself the option @c -DMY_API=CP_EXPORT would be passed to the compiler to
 * override the API header file and to mark the API symbols for export.
 * The overriding definition could also be included in module source files or
 * in an internal header file before including the API header file.
 */
/*@{*/

/**
 * @def CP_EXPORT
 *
 * Declares a symbol to be exported for inter-module usage. When compiling the
 * module which defines the symbol this macro should be placed
 * at the start of the symbol declaration to ensure that the symbol is exported
 * to other modules. However, when compiling other modules the declaration of
 * the symbol should start with #CP_IMPORT.
 * See @ref symbolVisibilityExample "the example" of how to do this.
 */

/**
 * @def CP_IMPORT
 *
 * Declares a symbol to be imported from another module. When compiling a
 * module which uses the symbol this macro should be placed at the start of
 * the symbol declaration to ensure that the symbol is imported from the
 * defining module. However, when compiling the defining module the declaration
 * of the symbol should start with #CP_EXPORT.
 * See @ref symbolVisibilityExample "the example" of how to do this.
 */

/**
 * @def CP_HIDDEN
 *
 * Declares a symbol hidden from other modules. This macro should be
 * placed at the start of the symbol declaration to hide the symbol from other
 * modules (if supported by the platform). This macro is not intended to be
 * used with symbols declared as "static" which are already internal to the
 * object file. Some platforms do not support hiding of symbols and therefore
 * unique prefixes should be used for global symbols internal to the module
 * even when they are declared using this macro.
 */

#if defined(_WIN32)
#  define CP_EXPORT __declspec(dllexport)
#  define CP_IMPORT extern __declspec(dllimport)
#  define CP_HIDDEN
#elif defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3))
#  define CP_EXPORT
#  define CP_IMPORT extern
#  define CP_HIDDEN __attribute__ ((visibility ("hidden")))
#else
#  define CP_EXPORT
#  define CP_IMPORT extern
#  define CP_HIDDEN
#endif

/*@}*/


/* ------------------------------------------------------------------------
 * Version information
 * ----------------------------------------------------------------------*/

/**
 * @defgroup versionInfo Version information
 * @ingroup cDefines cxxDefines
 *
 * C-Pluff version information. Notice that this version information
 * is static version information included in header files. The
 * macros introduced here can be used for compile time checks.
 *
 * Here is an example of how the compile time version information could be used
 * to create software that can be built against mutually incompatible
 * versions of the C-Pluff interface.
 *
 * @code
 * #if CP_IF_VERSION >= 42
 *   // code using interfaces introduced in the interface version 42
 * #elif CP_IF_VERSION >= 38
 *   // alternative compatibility support code for interface versions 38-41
 * #endif
 *
 * #if CP_IF_VERSION >= 42 && CP_IF_API_COMPATIBILITY <= 42
 *   // code written for the C-Pluff interface version 42
 * #endif
 * @endcode
 */
/*@{*/

/**
 * The C-Pluff release version string. Release version identifies a specific
 * version of the C-Pluff distribution. Software compatibility checks should
 * use interface version information instead.
 */
#define CP_RELEASE_VERSION "@PACKAGE_VERSION@"

/**
 * The version of this C-Pluff C/C++ interface. This is an integer number.
 * It is incremented whenever there have been changes to the interface.
 */
#define CP_IF_VERSION @CP_IF_VERSION@

/**
 * The version of the earliest C-Pluff C/C++ interface this interface is
 * backwards compatible with when it comes to the application programming
 * interface (API). That is, client software developed against any interface
 * version from @a CP_IF_API_COMPATIBILITY to #CP_IF_VERSION (inclusive) can be
 * successfully build against this interface.
 *
 * Notice that API is the compile time interface and therefore this describes
 * source level compatibility only. Binary compatibility depends on the
 * compatibility of the application binary interface (ABI) and it may be
 * more restricted.
 */
#define CP_IF_API_COMPATIBILITY @CP_IF_API_COMPATIBILITY@

/*@}*/


#endif /*CPLUFFDEF_H_*/
